#ifndef NODE_H
#define NODE_H

/*! \defgroup Kernel Kernel
    \brief Kernel defines the basic framework of Robot SDK.
*/

/*! \defgroup Core Core
    \ingroup Kernel
    \brief Core defines the basic Node and Edge.
*/

/*! \defgroup Modules Modules
    \ingroup Kernel
    \brief Modules defines the basic modular nodes.
*/

/*! \defgroup ExModules ExModules
    \ingroup Kernel
    \brief ExModules defines the extended modular nodes.
*/

/*! \defgroup Accessories Accessories
    \ingroup Kernel
    \brief Accessories defines the accessories of Robot SDK.
*/

/*! \defgroup Node_Library Node_Library
    \brief The library of the RobotSDK's node.
*/

/*! \defgroup Node_Class Node_CLass
    \brief The class of the RobotSDK's node.
*/

/*! \class QObject
    \brief QObject in Qt.
*/

/*! \defgroup Node Node
    \ingroup Core
    \brief Node in graph model.
*/

/*! \addtogroup Core
    @{
*/

/*! \file node.h
    \brief Defines the base class Node.
    \details Common node in graph model.
*/

#include<qmessagebox.h>
#include<qwidget.h>
#include<qapplication.h>
#include<qobject.h>
#include<qstring.h>
#include<qlibrary.h>
#include<qvector.h>
#include<qlist.h>
#include<qdatetime.h>
#include<qthread.h>
#include<qreadwritelock.h>
#include<boost/shared_ptr.hpp>

/*! \def LoadCheckFptr(sharedLibrary, funcPtrType, funcPtr, nodeType, nodeClass)
    \brief Load and check private interface functions \a funcPtrType \a nodeType_nodeClass_funcPtr from QLibrary \a sharedLibrary.
*/
#define LoadCheckFptr(sharedLibrary, funcPtrType, funcPtr, nodeType, nodeClass) \
    funcPtr=(funcPtrType) sharedLibrary.resolve(QString("%1_%2_%3").arg(nodeType).arg(nodeClass).arg(#funcPtr).toUtf8().constData()); \
    if(funcPtr==NULL){QMessageBox::information(NULL,QString("Node Interface Function Load Error"), QString("No function '%1_%2_%3' in Shared Library '%4'").arg(nodeType).arg(nodeClass).arg(#funcPtr).arg(sharedLibrary.fileName()));exit(0);}

/*! \def LoadCheckExFptr(sharedLibrary, funcPtrType, funcPtr, funcEx, nodeType, nodeClass)
    \brief Load and check private extended interface functions \a funcPtrType \a nodeType_nodeClass_funcPtr_funcEx from QLibrary \a sharedLibrary.
*/
#define LoadCheckExFptr(sharedLibrary, funcPtrType, funcPtr, funcEx, nodeType, nodeClass) \
    if(funcEx.size()>0){funcPtr=(funcPtrType) sharedLibrary.resolve(QString("%1_%2_%3_%4").arg(nodeType).arg(nodeClass).arg(#funcPtr).arg(funcEx).toUtf8().constData());} \
    else{funcPtr=(funcPtrType) sharedLibrary.resolve(QString("%1_%2_%3").arg(nodeType).arg(nodeClass).arg(#funcPtr).toUtf8().constData());}\
    if(funcPtr==NULL){QMessageBox::information(NULL,QString("Node Interface Function Load Error"), QString("No function '%1_%2_%3_%4' in Shared Library '%5'").arg(nodeType).arg(nodeClass).arg(#funcPtr).arg(funcEx).arg(sharedLibrary.fileName()));exit(0);}

/*! \def CHECKSTOP
    \brief The stop ratio of grubcount to buffersize
*/
#define CHECKSTOP 2

/*! \class InputPort
    \brief Class InputPort is the input port for node class to receive input data.
    \details
    - Input data is wrapped in the form of Qt signal generated by OutputPort.
    - InputPort is an universal port to receive this signal.
    - It is the front-end of Node.
        - Source: 0 port.
        - Drain: >0 port(s).
        - Processor: >0 port(s).
        - SourceDrain: >0 port(s).
    - It contains the previous node's parameters associated with the latest input data.
    - It contains a data buffer InputPort::inputdatabuffer to store the most recent input data in the size of InputPort::inputbuffersize.
    - It will run in an independent thread Node::inputportsthread to guarantee the data-stream will not be blocked.
*/
class InputPort : public QObject
{
    Q_OBJECT
public:
    /*! \fn InputPort(int inputBufferSize)
        \brief Determines the size of InputPort::inputdatabuffer.
        \param [in] inputBufferSize The size of the InputPort::inputdatabuffer.
        \details
        - If \a inputBufferSize>0, the length of the databuffer is limited to inputBufferSize.
        - If \a inputBufferSize<=0, the length of the databuffer is unlimited, which means all input data will be stored. It is strongly recommend not to set grabSize>0 in this mode.
        - The function InputPort::grabInputData(int grabSize) will grab and remove the stored data.
    */
    InputPort(int inputBufferSize);
    /* \fn virtual ~InputPort()
        \brief The destructor of the InputPort.
    */
    virtual ~InputPort();
protected:
    /*! \var inputbuffersize
        \brief The size of the InputPort::inputdatabuffer.
        \details
        - If InputPort::inputbuffersize>0, the length of the databuffer is limited to inputBufferSize.
        - If InputPort::inputbuffersize<=0, the length of the databuffer is unlimited, which means all input data will be stored. The function InputPort::grabInputData(int grabSize) will grab and remove the stored data.
    */
    int inputbuffersize;
    /*! \var inputparamsbuffer
        \brief Parameters from input node.
    */
    QList<boost::shared_ptr<void> > inputparamsbuffer;
    /*! \var inputdatabuffer
        \brief The input data buffer.
        \details
        - Front-end is the latest input data
        - Back-end is the oldest input data
    */
    QList<boost::shared_ptr<void> > inputdatabuffer;
    /*! \var readwritelock
        \brief A read & write lock for resource sharing between inputport's thread and node's thread.
    */
    QReadWriteLock readwritelock;
	/*! \var checkstop
        \brief Flag for checkstop.
    */
	bool checkstop;
	/*! \var paramsgrubcount
        \brief To count params grubbing for stop.
    */
	int paramsgrubcount;
	/*! \var datagrubcount
        \brief To count data grubbing for stop.
    */
	int datagrubcount;
public:
	/*! \fn int getInputBufferSize()
        \brief Get the \ref inputbuffersize.
    */
	int getInputBufferSize();
	/*! \fn void lock()
        \brief Lock inputport for data grabbing.
    */
	void lock();
	/*! \fn void unlock()
        \brief Unlock inputport.
    */
	void unlock();
    /*! \fn QVector<boost::shared_ptr<void> > grabInputParams(int grabSize)
        \brief Grab the input parameters in the size of \a grabSize from InputPort::inputparamsbuffer.
        \param [in] grabSize The size of grabbed input parameters.
        \return The grabbed input parameters in QVector.
    */
    QVector<boost::shared_ptr<void> > grabInputParams(int grabSize);
    /*! \fn QVector<boost::shared_ptr<void> > grabInputData(int grabSize)
        \brief Grab the input data in the size of \a grabSize from InputPort::inputdatabuffer.
        \param [in] grabSize The size of grabbed input data.
        \return The grabbed input data in QVector.
        \details
        - \a grabSize
            - \a grabSize==0 : all input data are grabbed. If InputPort::inputbuffersize<=0, all input data are removed from InputPort::inputdatabuffer.
            - \a grabSize>0 : grab the most recent input data in the size of \a grabSize without any removement. It is strongly recommend not to set InputPort::inputbuffersize=0 in this mode.
            - \a grabSize<0 : grab the most ancient input data of InputPort::inputdatabuffer in the size of \a grabSize. If InputPort::inputbuffersize<=0, the grabbed input data are removed from InputPort::inputdatabuffer.
        - \a The return value
            - Front-end is the latest grabbed data
            - Back-end is the oldest grabbed data
    */
    QVector<boost::shared_ptr<void> > grabInputData(int grabSize);
	/*! \fn void removeInputParamsData(int removeSize)
		\brief Remove \a removeSize elements in \ref inputparamsbuffer and \ref inputdatabuffer.
		\param [in] removeSize The size of removed elements.  
    */
	void removeInputParamsData(int removeSize);
    /*! \fn void clear()
        \brief Clear \ref inputparamsbuffer and \ref inputdatabuffer.
    */
    void clear();
	/*! \fn void setCheckStop(bool flag)
		\brief Set \ref checkstop
		\param [in] flag The value of \ref checkstop.  
    */
	void setCheckStop(bool flag);
public slots:
    /*! \fn void inputDataSlot(boost::shared_ptr<void> inputParamsPtr,  boost::shared_ptr<void> inputDataPtr)
        \brief The slot to receive input data signal OutputPort::outputDataSignal(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr) from OutputPort, which contains the data and parameters.
        \param [in] inputParamsPtr The parameters of input node.
        \param [in] inputDataPtr The input data.
    */
    void inputDataSlot(boost::shared_ptr<void> inputParamsPtr,  boost::shared_ptr<void> inputDataPtr);
signals:
    /*! \fn void inputDataSignal()
        \brief The signal to Node as a trigger if connected.
    */
    void inputDataSignal();
};

/*! \class OutputPort
    \brief Class OutputPort is the output port for node class to send output data.
    \details
    - Output data is wrapped in the form of Qt signal generated by OutputPort.
    - OutputPort is an universal port to send this signal.
    - It is the back-end of Node.
        - Source: >0 port(s).
        - Drain: 0 port.
        - Processor: >0 port(s).
        - SourceDrain: >0 port(s).
    - It sends the current node's parameters associated with the output data.
    - It does not contain any data buffer to store the output data.
    - It will run in the thread contains its Node.
*/
class OutputPort : public QObject
{
    Q_OBJECT
public:
    /*! \fn OutputPort(QObject * parent)
        \brief Determines the parent Node of OutputPort.
        \param [in] parent The parent of the Output.
        \details
        If the \a is NULL, then the OutputPort will not be automatically moved into the thread which contains its Node.
    */
    OutputPort(QObject * parent);
    /* \fn virtual ~OutputPort()
        \brief The destructor of the OutputPort.
    */
    virtual ~OutputPort();
public:
    /*! \fn void outputData(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr)
        \brief The function called by Node to send output data signal OutputPort::outputDataSignal(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr) contains parameters and data.
        \param [in] outputParamsPtr The parameters of the Node.
        \param [in] outputDataPtr The data will be sent.
    */
    void outputData(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr);
signals:
    /*! \fn void outputDataSignal(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr)
        \brief The output data signal contains the current Node's parameters and data
        \param [in] outputParamsPtr The parameters of the Node.
        \param [in] outputDataPtr The data will be sent.
    */
    void outputDataSignal(boost::shared_ptr<void> outputParamsPtr, boost::shared_ptr<void> outputDataPtr);
};

/*! \class Node
    \brief Class Node is the base for other modular node class in the data-stream graph model.
    \details
    There are four kinds of modular node (modules):
    - Source: \image html Source.png
    - Drain: \image html Drain.png
    - Processor: \image html Processor.png
    - SourceDrain: \image html Source-Drain.png

    Remarks:
    - Node cannot be used directly in the application.
    - Provides 7 interface functions:
        - [public] Node::setNodeClass
        - [private] Node::getPortsSize
        - [private] Node::initializeParams
        - [private] Node::initializeVars
        - [private] Node::setParamsVarsOpenNode
        - [private] Node::handleVarsCloseNode
        - [private, optional] Node::getInternalTrigger
        - [private, optional] Node::getVisualizationWidget

        public: function interface without prefix. (see LoadCheckPublicFptr(sharedLibrary, funcPtrType, funcPtr)) \n
        private: function interface with prefix "NodeType_NodeClass_". (see LoadCheckFptr(sharedLibrary, funcPtrType, funcPtr, nodeType, nodeClass)) \n
        optional: function interface is optional. (see LoadPublicFptr(sharedLibrary, funcPtrType, funcPtr) or LoadPrivateFptr(sharedLibrary, funcPtrType, funcPtr, nodeType, nodeClass))
    - Provides 2 set of Qt Signal-Slot:
        - Open node
            - [slot] Node::openNodeSlot()
            - [signal] Node::openNodeSignal()
            - [signal] Node::openNodeErrorSignal()
        - Close node
            - [slot] Node::closeNodeSlot()
            - [signal] Node::closeNodeSignal()
            - [signal] Node::closeNodeErrorSignal()
    - Provides 1 set of trigger link functions
        - Node::connectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal)
        - Node::connectExternalTrigger(int inputPortIndex)
        - Node::connectInternalTrigger();
        - Node::disconnectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal);
        - Node::disconnectExternalTrigger(int inputPortIndex);
        - Node::disconnectInternalTrigger();
    - Provides a set of time tracker method
        - Node::NodeTriggerState
        - Node::nodeTriggerTime(NodeTriggerState nodeTriggerState)
        - Node::nodeTriggerTimeSignal(QString nodeMark, QDateTime curTime, NodeTriggerState nodeTriggerState)
*/
class Node : public QObject
{
    Q_OBJECT
public:
    /*! \fn Node(QString qstrSharedLibrary, QString qstrNodeType, QString qstrNodeClass, QString qstrNodeName, QString qstrConfigName)
        \brief The constructor of the class Node.
        \param [in] qstrSharedLibrary The name of the shared library. (No _)
        \param [in] qstrNodeType The type-name of the node. (No _)
        \param [in] qstrNodeClass The class-name of the node. (Yes _)
        \param [in] qstrNodeName The node-name of the node. (Yes _)
        \param [in] qstrConfigName The name of the config file. (Yes _)
        \details
        - Load and check the shared library.
        - Set the node's type-name, class-name and node-name.
        - Initialize the pointer \ref Node::paramsptr and \ref Node::varsptr.
        - Initialize the inputports and outputports.
        - Deployed in the threads
    */
    Node(QString qstrSharedLibrary, QString qstrNodeType, QString qstrNodeClass, QString qstrNodeName, QString qstrConfigName);
    /*! \fn virtual ~Node();
        \brief The destructor of the class Node.
    */
    virtual ~Node();
protected:
    /*! \var sharedlibrary
        \brief A Qt interface to load modular node's shared library.
    */
    QLibrary sharedlibrary;
    /*! \var configname
        \brief %Node's config-name.
    */
    QString configname;
    /*! \var nodetype
        \brief %Node's type-name. e.g. "Source", "Sensor".
    */
    QString nodetype;
    /*! \var nodeclass
        \brief %Node's class-name. e.g. "URG", "LMS".
    */
    QString nodeclass;
    /*! \var nodename
        \brief %Node's node-name. e.g. "urg1", "urg2".
    */
    QString nodename;
    /*! \var paramsptr
        \brief A void-type pointer to the node's parameters.
    */
    boost::shared_ptr<void> paramsptr;
    /*! \var varsptr
        \brief A void-type pointer to the node's variables.
    */
    boost::shared_ptr<void> varsptr;
    /*! \var openflag
        \brief A flag to show node open status.
    */
    bool openflag;
    /*! \var inputportsthread
        \brief A thread for input ports to receive input data.
    */
    QThread inputportsthread;
    /*! \var inputports
        \brief The input ports that receive data.
    */
    QVector<InputPort *> inputports;
    /*! \var outputports
        \brief The output ports that send data.
    */
    QVector<OutputPort *> outputports;
    /*! \var inputnodesname
        \brief The node-name of input nodes
    */
    QVector<QString> inputnodesname;
    /*! \var outputnodesname
        \brief The node-name of output nodes
    */
    QVector<QString> outputnodesname;
public:
    /*! \fn QString getSharedLibraryName()
        \brief Get the name of the shared library.
        \return The name of the shared library.
    */
    QString getSharedLibraryName();
    /*! \fn QString getNodeType()
        \brief Get the type-name of the node.
        \return The type-name of the node.
    */
    QString getNodeType();
    /*! \fn QString getNodeClass()
        \brief Get the class-name of the node.
        \return The class-name of the node.
    */
    QString getNodeClass();
    /*! \fn QString getNodeName()
        \brief Get the node-name of the node.
        \return The node-name of the node.
    */
    QString getNodeName();
    /*! \fn QString getConfigName()
        \brief Get the config-name of the node.
        \return The config-name of the node.
    */
    QString getConfigName();
    /*! \fn void * getParamsPtr()
        \brief Get the void-type pointer to the memory space of the node's parameters.
        \return The void-type pointer to the memory space of the node's parameters.
    */
    void * getParamsPtr();
    /*! \fn void * getVarsPtr()
        \brief Get the void-type pointer to the memory space of the node's variables.
        \return The void-type pointer to the memory space of the node's variables.
    */
    void * getVarsPtr();
    /*! \fn bool connectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal, const char * triggerSlot)
        \brief Connect external trigger, such as QTimer.
        \param [in] externalTrigger The external trigger.
        \param [in] externalTriggerSignal The external trigger signal.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
    */
    bool connectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal, const char * triggerSlot);
    /*! \fn bool connectExternalTrigger(int inputPortIndex, const char * triggerSlot)
        \brief Connect InputPort as external trigger (InputPort::inputDataSignal()).
        \param [in] inputPortIndex The index of input port.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
    */
    bool connectExternalTrigger(int inputPortIndex, const char * triggerSlot);
    /*! \fn bool connectInternalTrigger(const char * triggerSlot)
        \brief Connect internal trigger stored in Node::varsptr.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
        \sa void (*getInternalTriggerFptr)(void * paramsPtr, void * varsPtr, QObject * & internalTrigger, QString & internalTriggerSignal).
    */
    bool connectInternalTrigger(const char * triggerSlot);
    /*! \fn bool disconnectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal, const char * triggerSlot)
        \brief Disconnect external trigger, such as QTimer.
        \param [in] externalTrigger The external trigger.
        \param [in] externalTriggerSignal The external trigger signal.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
    */
    bool disconnectExternalTrigger(QObject * externalTrigger, const char * externalTriggerSignal, const char * triggerSlot);
    /*! \fn bool disconnectExternalTrigger(int inputPortIndex, const char * triggerSlot)
        \brief Disconnect InputPort as external trigger (InputPort::inputDataSignal()).
        \param [in] inputPortIndex The index of input port.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
    */
    bool disconnectExternalTrigger(int inputPortIndex, const char * triggerSlot);
    /*! \fn bool disconnectInternalTrigger(const char * triggerSlot)
        \brief Disconnect internal trigger stored in Node::varsptr.
        \param [in] triggerSlot The slot to receive trigger signal.
        \return 1 for success and 0 for failure.
        \sa void (*getInternalTriggerFptr)(void * paramsPtr, void * varsPtr, QObject * & internalTrigger, QString & internalTriggerSignal).
    */
    bool disconnectInternalTrigger(const char * triggerSlot);
    /*! \fn void setInputNodesName(QList<QString> inputNodesName)
        \brief Set the node-name of input nodes
        \param [in] inputNodesName The node-name of input nodes.
        \details
        The inputNodesName=QStringList()<<"Name1"<<"Name2;Name3";
    */
    void setInputNodesName(QList<QString> inputNodesName);
    /*! \fn void setOutputNodesName(QList<QString> outputNodesName)
        \brief Set the node-name of output nodes
        \param [in] outputNodesName The node-name of output nodes.
        The outputNodesName=QStringList()<<"Name1"<<"Name2;Name3";
    */
    void setOutputNodesName(QList<QString> outputNodesName);
    /*! \fn QVector<QString> getInputNodesName()
        \brief Get the name of input nodes.
        \return The name of input nodes.
    */
    QVector<QString> getInputNodesName();
    /*! \fn QVector<QString> getOutputNodesName()
        \brief Get the name of output nodes.
        \return The name of output nodes.
    */
    QVector<QString> getOutputNodesName();
    /*! \fn InputPort * getInputPort(int inputPortIndex)
        \brief Get input port.
        \param [in] inputPortIndex The index of the input port.
        \return The input port in Node::inputports.
    */
    InputPort * getInputPort(int inputPortIndex);
    /*! \fn OutputPort * getOutputPort(int outputPortIndex)
        \brief Get output port.
        \param [in] outputPortIndex The index of the output port.
        \return The output port in Node::outputports.
    */
    OutputPort * getOutputPort(int outputPortIndex);
public:
    /*! \enum NodeTriggerState
        \brief The state of triggered node.
        \details
        - NodeTriggerStart: triggered node started.
        - NodeTriggerEnd: triggered node ended normally.
        - NodeTriggerError: triggered node ended with error.
    */
    enum NodeTriggerState
    {
        UnknownSate,
        NodeTriggerStart,
        NodeTriggerEnd,
        NodeTriggerError
    };
protected:
    /*! \fn void nodeTriggerTime(NodeTriggerState nodeTriggerState)
        \brief Function called by node to send Node::nodeTriggerTimeSignal(QString nodeMark, QDateTime curTime, NodeTriggerState nodeTriggerState).
        \param [in] nodeTriggerState The state of the triggered node.
        \sa Node::NodeTriggerState
    */
    void nodeTriggerTime(NodeTriggerState nodeTriggerState);
    /*! \fn QVector<void *> convertBoostData(QVector<boost::shared_ptr<void> > & boostData)
        \brief Convert a set of boost shared_ptrs to a set of void pointers
        \param [in] boostData Boost data to be converted.
        \return Void data converted.
    */
    QVector<void *> convertBoostData(QVector<boost::shared_ptr<void> > & boostData);
protected:
    /*! \typedef  void (*getPortsSizeFptr)(QList<int> & inputPortsSize, int & outputPortsNumber)
        \brief [required] Function pointer type for interface function of getting node's port(s)' size.
        \param [out] inputPortsSize The size of each input port's data buffer.
        \param [out] outputPortsNumber The number of output ports.
    */
    typedef void (*getPortsSizeFptr)(QList<int> & inputPortsSize, int & outputPortsNumber);
    /*! \typedef void (*initializeParamsFptr)(boost::shared_ptr<void> & paramsPtr)
        \brief [required] Function pointer type for interface function of initializing node's parameters.
        \param [out] paramsPtr The parameters embelished by boost::shared_pointer<void>.
        \details To initialize parameters:
        - paramsPtr=boost::shared_ptr<void> (new ParametersType);
    */
    typedef void (*initializeParamsFptr)(boost::shared_ptr<void> & paramsPtr);
    /*! \typedef void (*initializeVarsFptr)(boost::shared_ptr<void> & varsPtr)
        \brief [required] Function pointer type for interface function of initializing node's variables.
        \param [out] varsPtr The variables embelished by boost::shared_pointer<void>.
        \details To initialize variables:
        - varsPtr=boost::shared_ptr<void> (new VariablesType);
    */
    typedef void (*initializeVarsFptr)(boost::shared_ptr<void> & varsPtr);
    /*! \typedef bool (*setParamsVarsOpenNodeFptr)(QString qstrConfigName, QString qstrNodeType, QString qstrNodeClass, QString qstrNodeName, void * paramsPtr, void * varsPtr)
        \brief [required] Function pointer type for interface function of setting node's parameters and variables while openning node.
        \param [in] qstrConfigName The config-name of the node.
        \param [in] qstrNodeType The type-name of the node.
        \param [in] qstrNodeClass The class-name of the node.
        \param [in] qstrNodeName The node-name of the node.
        \param [in,out] paramsPtr The parameters(\ref Node::paramsptr) to be loaded.
        \param [in,out] varsPtr The variables(\ref Node::varsptr) to be set
        \return 1 for success and 0 for failure.
    */
    typedef bool (*setParamsVarsOpenNodeFptr)(QString qstrConfigName, QString qstrNodeType, QString qstrNodeClass, QString qstrNodeName, void * paramsPtr, void * varsPtr);
    /*! \typedef bool (*handleVarsCloseNodeFptr)(void * paramsPtr, void * varsPtr)
        \brief [required] Function pointer type for interface function of handling node's variables while closing node.
        \param [in] paramsPtr The parameters(\ref Node::paramsptr) for setting variables.
        \param [in,out] varsPtr The variables(\ref Node::varsptr) to be handled
        \return 1 for success and 0 for failure.
    */
    typedef bool (*handleVarsCloseNodeFptr)(void * paramsPtr, void * varsPtr);
    /*! \typedef void (*getInternalTriggerFptr)(void * paramsPtr, void * varsPtr, QObject * & internalTrigger, QString & internalTriggerSignal)
        \brief [optional] Function pointer type for interface function of getting node's internal trigger.
        \param [in] paramsPtr The node's parameters(\ref Node::paramsptr).
        \param [in] varsPtr The node's variables(\ref Node::varsptr) that contains internal trigger.
        \param [out] internalTrigger The internal trigger.
        \param [out] internalTriggerSignal The internal trigger signal embelished by QString.
        \details To embelish internal trigger signal:
        - QString(SIGNAL(<internal trigger signal>));
    */
    typedef void (*getInternalTriggerFptr)(void * paramsPtr, void * varsPtr, QObject * & internalTrigger, QString & internalTriggerSignal);
protected:
    /*! \var getPortsSize
        \brief [private] Interface function of getting node's port(s)' size.
    */
    getPortsSizeFptr getPortsSize;
    /*! \var initializeParams
        \brief [private] Interface function of initializing node's parameters.
    */
    initializeParamsFptr initializeParams;
    /*! \var initializeVars
        \brief [private] Interface function of initializing node's variables.
    */
    initializeVarsFptr initializeVars;
    /*! \var setParamsVarsOpenNode
        \brief [private] Interface function of setting node's parameters and variables while openning node.
    */
    setParamsVarsOpenNodeFptr setParamsVarsOpenNode;
    /*! \var handleVarsCloseNode
        \brief [private] Interface function of handling node's variables while closing node.
    */
    handleVarsCloseNodeFptr handleVarsCloseNode;
    /*! \var getInternalTrigger
        \brief [private] Interface function of getting node's internal trigger.
    */
    getInternalTriggerFptr getInternalTrigger;
public slots:
    /*! \fn virtual void openNodeSlot()
        \brief The slot function for openning node.
    */
    virtual void openNodeSlot();
    /*! \fn virtual void closeNodeSlot()
        \brief The slot function for closing node.
    */
    virtual void closeNodeSlot();
signals:
    /*! \fn void openNodeSignal()
        \brief The signal function for openning node normally.
    */
    void openNodeSignal();
    /*! \fn void openNodeErrorSignal()
        \brief The signal function for openning node with error.
    */
    void openNodeErrorSignal();
    /*! \fn void closeNodeSignal()
        \brief The signal function for closing node normally.
    */
    void closeNodeSignal();
    /*! \fn void closeNodeErrorSignal()
        \brief The signal function for closing node with error.
    */
    void closeNodeErrorSignal();
signals:
    /*! \fn void nodeTriggerTimeSignal(QDateTime curDateTime, NodeTriggerState nodeTriggerState)
        \brief The signal function for time tracker of triggered node.
        \param [in] curDateTime Current date and time.
        \param [in] nodeTriggerState The state of the triggered node.
    */
    void nodeTriggerTimeSignal(QDateTime curDateTime, Node::NodeTriggerState nodeTriggerState);
};

/*! @}*/

#endif
